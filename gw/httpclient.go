package gw

import (
	"crypto/tls"
	"io/ioutil"
	"net/http"
	"time"

	"github.com/Moonyongjung/anchor/manage"
	"github.com/Moonyongjung/anchor/parse"
	ctypes "github.com/Moonyongjung/anchor/types"
	"github.com/Moonyongjung/anchor/util"
)

//-- Watching private Blockchain
//   For testing, connect to cosmos or terra blockchain based on tendermint core
func RunHttpClient(channel ctypes.ChannelStruct) {
	//-- For test
	// collectBlockCount := util.GetConfig().Get("collectBlockCount")
	// intCount, _ := util.ToInt(collectBlockCount)
	for {
		select {
		case httpClientStartSignal := <- channel.HttpClientStartSignal:
			targetNodeInfo := util.GetConfig().Get("targetNodeInfoTerra")
			util.LogHttpClient("HTTP client request target : " + targetNodeInfo)

			if httpClientStartSignal {
				//-- Using infinite loop when PROD
				// for i := 0; i < intCount; i ++ {
				for {
					doRequest(targetNodeInfo, channel)
					manage.BlockListMng().IncreaseLatestBlockHeight()
					time.Sleep(time.Second/2)
				}
			}
		}
	}	
}

func doRequest(targetNodeInfo string, channel ctypes.ChannelStruct) {
	httpClientApiName := util.GetConfig().Get("httpClientApiName")
	blockHeight := manage.BlockListMng().NowLatestBlockHeight()
	util.LogHttpClient("latest block :" + blockHeight)
	
	url := targetNodeInfo + httpClientApiName + blockHeight	

	request, err := http.NewRequest("GET", url, nil)
	if err != nil {
		util.LogHttpClient(err)
	}

	hClient := &http.Client{
		Transport: &http.Transport{
			TLSClientConfig: &tls.Config{
				InsecureSkipVerify: true,
			},
		},
	}
	hClient.Timeout = time.Second * 30
	defer func() {
		if err := recover(); err != nil {
			util.LogHttpClient(err)		
		}
	}()
	response, err := hClient.Do(request)
	if err != nil {
		util.LogHttpClient(err)
	}
	defer response.Body.Close()

	responseBody, err := ioutil.ReadAll(response.Body)
	if err != nil {
		util.LogHttpClient(err)
	}
	
	response.Body.Close()

	var responseStruct ctypes.AutoGenerated
	responseData := util.JsonUnmarshalData(responseStruct, responseBody)

	parse.SaveBlock(responseData, blockHeight, channel)
}


